<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zaha Hadid | Digital Archive</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* UI ARAYÜZ KATMANI */
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header {
            color: #00ffcc;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
        }

        h1 { margin: 0; font-weight: 300; letter-spacing: 5px; font-size: 24px; text-transform: uppercase; }
        .sub { font-size: 10px; opacity: 0.7; letter-spacing: 2px; }

        .stats {
            align-self: flex-end;
            text-align: right;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            font-family: monospace;
            line-height: 1.5;
        }

        .scan-line {
            width: 100%; height: 1px;
            background: linear-gradient(90deg, transparent, #00ffcc, transparent);
            position: absolute; top: 50%; left: 0;
            opacity: 0.2;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ffcc; font-family: monospace; font-size: 12px;
            animation: blink 1s infinite;
        }

        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="loading">GENERATING GEOMETRY...</div>

    <div id="ui">
        <div class="header">
            <h1>Structure_01</h1>
            <div class="sub">HEYDAR ALIYEV CENTER // BAKU</div>
            <div class="sub">PARAMETRIC RECONSTRUCTION</div>
        </div>
        <div class="stats">
            <div>VERTICES: <span id="v-count">0</span></div>
            <div>POLY COUNT: HIGH</div>
            <div>RENDERING: WEBGL2</div>
            <div>SCANNING_SECTOR: <span id="scan-val">00</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
        // --- SAHNE KURULUMU ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020202); // Derin siyah/gri
        scene.fog = new THREE.FogExp2(0x020202, 0.015);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(-30, 15, 40); // Fotoğrafa benzer bir açı

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2; // Yerin altına girmeyi engelle

        // --- GELİŞMİŞ GEOMETRİ ALGORİTMASI ---
        // Zaha Hadid'in yapısını taklit eden özel fonksiyon
        
        // Grid boyutu (Ne kadar yüksek olursa o kadar detaylı)
        const SEGMENTS_X = 150; 
        const SEGMENTS_Z = 150;
        const geometry = new THREE.PlaneGeometry(60, 60, SEGMENTS_X, SEGMENTS_Z);
        
        const count = geometry.attributes.position.count;
        const positions = geometry.attributes.position;

        // Geometriyi manipüle et
        for (let i = 0; i < count; i++) {
            const x = positions.getX(i);
            const y = positions.getY(i); // PlaneGeometry'de Y aslında derinliktir, biz Z yapacağız
            const z = positions.getZ(i); // PlaneGeometry'de Z sıfırdır

            // Koordinatları düzelt (Three.js koordinat sistemine göre yatay düzlem)
            // x = x, y (height) = 0, z = y (from loop)
            // Bizim için X: Genişlik, Z: Derinlik, Y: Yükseklik olacak.
            
            // --- MATEMATİKSEL FORMÜL ---
            // 1. Temel Dalga (Wave):
            let height = 0;

            // Normalize edilmiş koordinatlar (-1 ile 1 arası gibi düşünelim)
            const nx = x / 30;
            const nz = y / 30; // Not: PlaneGeometry'nin Y'si bizim Z'miz oluyor

            // Ana Tepe (The Main Peak) - Binanın yüksek camlı kısmı
            // X ekseninde hafif kayık bir Gaussian eğrisi
            const peak = 18 * Math.exp(-1.5 * (Math.pow(nx + 0.2, 2) + Math.pow(nz, 2)));

            // Kabuk Kıvrımı (The Shell Curl)
            // Yere doğru süzülen etek kısımları
            const wave = 5 * Math.cos(nx * 2.5) * Math.cos(nz * 2.5);

            // Zemin ile birleştirme (Smooth blend)
            // Kenarlara gittikçe sıfıra yaklaşsın
            const edgeFactor = Math.max(0, 1 - Math.sqrt(nx*nx + nz*nz));
            
            // Asimetrik akış (Fotoğraftaki gibi sol tarafın kıvrılıp inmesi)
            const asymmetry = Math.sin(nx + nz) * 2;

            // Hepsini birleştir
            // Formül: Tepe noktası + dalga etkisi, ama kenarlara gidince sönümleniyor.
            height = (peak + wave * 0.5 + asymmetry) * edgeFactor;

            // Negatif değerleri (yerin altı) düzelt, zemin düz olsun
            if (height < 0) height = 0;

            // Fotoğraftaki gibi ön yüzün "kesik" ve dik olması için:
            // Ön tarafa doğru (z pozitifken) eğimi sertleştiriyoruz.
            if (nz > 0.2 && height > 1) {
                height *= 1 - (nz - 0.2); 
            }

            // Pozisyonları güncelle
            positions.setZ(i, y); // Plane'in Y'si Z oluyor
            positions.setY(i, height); // Yükseklik hesaplanan değer
        }

        geometry.computeVertexNormals();

        // --- MATERYAL VE GÖRSEL EFEKTLER ---

        // Shader Material: Matrix/Blueprint hissi veren özel materyal
        // Vertex'lerin yüksekliğine ve tarama çizgisine göre renk değiştirecek.
        
        const vertexShader = `
            varying vec3 vPos;
            varying float vScan;
            uniform float uTime;
            
            void main() {
                vPos = position;
                
                // Tarama çizgisi efekti (Z ekseninde hareket eder)
                float scanPos = sin(uTime * 0.5) * 30.0;
                float dist = abs(position.z - scanPos);
                
                // Eğer scan çizgisine yakınsa vScan değeri artar
                vScan = 1.0 - smoothstep(0.0, 5.0, dist);

                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vPos;
            varying float vScan;
            
            void main() {
                // Temel ızgara rengi (Koyu yeşil/mavi)
                vec3 baseColor = vec3(0.0, 0.2, 0.2);
                
                // Tarama çizgisi rengi (Parlak Cyan/Beyaz)
                vec3 scanColor = vec3(0.0, 1.0, 0.8);
                
                // Yüksekliğe göre hafif renk değişimi
                float heightGlow = vPos.y / 20.0;
                baseColor += vec3(0.0, heightGlow * 0.5, heightGlow);

                // Grid çizgileri oluşturma (Wireframe benzeri ama shader ile)
                // Bu teknik wireframe:true yerine shader içinde grid çizer, daha estetiktir.
                // Modulo kullanarak çizgileri buluyoruz
                float gridX = step(0.98, fract(vPos.x * 0.5)); // Sıklık
                float gridZ = step(0.98, fract(vPos.z * 0.5));
                float gridLine = max(gridX, gridZ);

                // Renkleri karıştır
                vec3 finalColor = mix(baseColor * 0.1, baseColor, gridLine);
                
                // Tarama ışığını ekle
                finalColor += scanColor * vScan * gridLine * 2.0;
                
                // Sadece çizgileri ve biraz dolguyu göster
                float alpha = 0.1 + (gridLine * 0.8) + (vScan * 0.5);

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 }
            },
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false, // Glow efektleri için önemli
            blending: THREE.AdditiveBlending // Işıkların üst üste binip parlaması için
        });

        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Zemin Izgarası (Daha geniş perspektif için)
        const floorGrid = new THREE.GridHelper(200, 50, 0x111111, 0x050505);
        floorGrid.position.y = -0.1;
        scene.add(floorGrid);

        // --- PARÇACIK EFEKTİ (Veri noktaları) ---
        // Sadece binanın tepe noktalarına rastgele "veri" noktaları koyalım
        const particlesGeometry = new THREE.BufferGeometry();
        const particleCount = 2000;
        const pArray = new Float32Array(particleCount * 3);

        for(let i=0; i<particleCount * 3; i+=3) {
            // Rastgele bir nokta seç (geometry içinden)
            const rIndex = Math.floor(Math.random() * (positions.count));
            pArray[i] = positions.getX(rIndex);
            pArray[i+1] = positions.getY(rIndex);
            pArray[i+2] = positions.getZ(rIndex);
        }
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(pArray, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00ffcc,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });
        const particles = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particles);


        // --- POST PROCESSING (BLOOM EFEKTİ / PARLAMA) ---
        const renderScene = new THREE.RenderPass(scene, camera);
        
        // UnrealBloomPass parametreleri: Resolution, Strength, Radius, Threshold
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // Parlaklık şiddeti
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- ANIMASYON ---
        document.getElementById('loading').style.display = 'none';
        document.getElementById('v-count').innerText = positions.count;

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();

            // Shader'a zamanı gönder (Tarama çizgisi için)
            material.uniforms.uTime.value = elapsedTime;

            // Hafif kamera hareketi (Nefes alma hissi)
            mesh.rotation.y = Math.sin(elapsedTime * 0.05) * 0.05;
            
            // Parçacıklar hafifçe yukarı süzülsün
            const pPos = particles.geometry.attributes.position.array;
            for(let i=1; i<particleCount*3; i+=3) {
                pPos[i] += 0.01; // Y ekseninde yukarı
                if (pPos[i] > 20) pPos[i] = 0; // Çok yükselirse sıfırla
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // UI Güncelleme
            document.getElementById('scan-val').innerText = Math.floor((Math.sin(elapsedTime) + 1) * 50);

            controls.update();
            // renderer.render(scene, camera); yerine composer kullanıyoruz
            composer.render();
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
