<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix City Architect</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }

        /* MATRIX ARAYÜZ STİLİ (SOL PANEL) */
        #gui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            background: rgba(0, 10, 0, 0.85);
            border: 1px solid #0F0;
            padding: 20px;
            color: #0F0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
            z-index: 10;
            backdrop-filter: blur(5px);
        }

        h2 {
            margin: 0 0 15px 0;
            font-size: 18px;
            text-transform: uppercase;
            border-bottom: 1px solid #0F0;
            padding-bottom: 5px;
            letter-spacing: 1px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        /* Matrix Tarzı Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #003300;
            border: 1px solid #0F0;
        }

        input[type=range]::-webkit-slider-thumb {
            height: 14px;
            width: 14px;
            background: #0F0;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -6px;
            box-shadow: 0 0 5px #0F0;
        }

        .status-text {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 20px;
            line-height: 1.5;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #0F0;
            font-size: 24px;
            pointer-events: none;
            display: none;
            text-shadow: 0 0 10px #0F0;
        }
    </style>
</head>
<body>

    <div id="gui-panel">
        <h2>MATRIX ARCHITECT</h2>
        
        <div class="control-group">
            <label>City Spread (Radius) <span id="val-spread">60</span></label>
            <input type="range" id="spread" min="20" max="150" value="60">
        </div>

        <div class="control-group">
            <label>Building Height <span id="val-height">1.0</span></label>
            <input type="range" id="height" min="0.5" max="4.0" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <label>Particle Density <span id="val-density">50%</span></label>
            <input type="range" id="density" min="10" max="90" value="50">
        </div>

        <div class="status-text">
            > SYSTEM: ONLINE<br>
            > RENDERING: PROCEDURAL_CITY<br>
            > MOUSE: ORBIT / ZOOM
        </div>
    </div>

    <div id="loading">GENERATING NEW MATRIX...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- TEMEL KURULUM ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015); // Derinlik için sis

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.set(0, 40, 80);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- DEĞİŞKENLER ---
        let citySystem; // Nokta bulutu sistemimiz
        
        // Parametreler (Varsayılan)
        const params = {
            spread: 60,      // Şehrin genişliği
            heightMod: 1.5,  // Yükseklik çarpanı
            density: 0.5     // Bina doluluk oranı
        };

        // --- ŞEHİR OLUŞTURMA FONKSİYONU ---
        function generateCity() {
            // Eğer eski bir şehir varsa sahneden sil
            if (citySystem) {
                scene.remove(citySystem);
                citySystem.geometry.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = []; // Renk varyasyonları için

            // Grid ayarları
            const gridSize = params.spread; 
            const step = 2; // Binalar arası boşluk

            // Grid döngüsü
            for (let x = -gridSize; x <= gridSize; x += step) {
                for (let z = -gridSize; z <= gridSize; z += step) {
                    
                    // 1. Şehir sınırlarını belirle (Dairesel yapı)
                    const dist = Math.sqrt(x*x + z*z);
                    if (dist > gridSize) continue;

                    // 2. Rastgelelik (Perlin noise yerine basit Math.random kullanıyoruz)
                    // Merkezde binalar daha yoğun, kenarlarda daha seyrek
                    const chance = Math.random();
                    const densityThreshold = 1 - params.density; // Slider'a göre eşik
                    
                    // Merkezden uzaklaştıkça bina olma ihtimalini düşür
                    const falloff = 1 - (dist / gridSize); 

                    if (chance > densityThreshold - (falloff * 0.2)) {
                        
                        // Bu noktada bir bina var! Şimdi binayı "pixel" olarak inşa edelim.
                        
                        // Bina yüksekliği: Merkezde yüksek, kenarda alçak + rastgelelik
                        let buildingHeight = (Math.random() * 20 + 5) * falloff * params.heightMod;
                        
                        // Çok kısa binaları ele (zemin gürültüsü)
                        if (buildingHeight < 2) buildingHeight = 0;

                        // Binanın dikey noktalarını oluştur (Katlar gibi)
                        for (let y = 0; y < buildingHeight; y += 0.8) {
                            positions.push(x, y, z);

                            // Renk hesaplama: Tabanda koyu yeşil, tepede parlak beyaz/yeşil
                            // Matrix kodu gibi parlaması için
                            if (y > buildingHeight - 2) {
                                // Çatı kısımları daha parlak
                                colors.push(0.8, 1.0, 0.8);
                            } else {
                                // Alt kısımlar klasik Matrix yeşili
                                colors.push(0.0, Math.random() * 0.5 + 0.2, 0.0);
                            }
                        }
                    }
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Matrix materyali (Noktalar)
            const material = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true, // Her noktanın kendi rengi olsun
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending // Parlama efekti verir
            });

            citySystem = new THREE.Points(geometry, material);
            scene.add(citySystem);
            
            console.log("City Generated. Points:", positions.length / 3);
        }

        // --- ZEMİN GRID'İ (Infinite Grid hissi için) ---
        const gridHelper = new THREE.GridHelper(300, 100, 0x004400, 0x001100);
        scene.add(gridHelper);

        // --- UI BAĞLANTILARI ---
        const elSpread = document.getElementById('spread');
        const elHeight = document.getElementById('height');
        const elDensity = document.getElementById('density');
        
        const valSpread = document.getElementById('val-spread');
        const valHeight = document.getElementById('val-height');
        const valDensity = document.getElementById('val-density');

        function updateCity() {
            // Değerleri güncelle
            params.spread = parseInt(elSpread.value);
            params.heightMod = parseFloat(elHeight.value);
            params.density = parseInt(elDensity.value) / 100;

            // Etiketleri güncelle
            valSpread.innerText = params.spread;
            valHeight.innerText = params.heightMod.toFixed(1) + "x";
            valDensity.innerText = elDensity.value + "%";

            // Şehri yeniden oluştur
            generateCity();
        }

        // Event Listeners (Slider değişince çalışır)
        elSpread.addEventListener('input', updateCity);
        elHeight.addEventListener('input', updateCity);
        elDensity.addEventListener('input', updateCity);

        // İlk başlatma
        generateCity();

        // --- ANIMASYON DÖNGÜSÜ ---
        function animate() {
            requestAnimationFrame(animate);
            
            // Hafif kamera hareketi
            controls.update();
            
            // Şehre hafif bir "veri akışı" titremesi ekleyebiliriz (Opsiyonel)
            // Performans için şu an kapalı, statik render daha net.

            renderer.render(scene, camera);
        }

        // Pencere Boyutlandırma
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
