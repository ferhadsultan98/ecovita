<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Ger√ßek√ßi Deniz & Hava Sim√ºlasyonu</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI Aray√ºz√º - Mobil Uyumlu */
        #ui-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: rgba(15, 23, 42, 0.85); /* Glassmorphism koyu */
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
            transition: opacity 0.3s;
        }

        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 14px;
        }

        .control-group label { min-width: 100px; font-weight: 600; color: #94a3b8; }
        
        /* Slider Stili */
        input[type=range] {
            flex-grow: 1;
            margin-left: 10px;
            accent-color: #38bdf8;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.5);
        }

        /* Buton Grubu */
        .weather-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 5px;
        }

        .weather-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            padding: 10px 5px;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            text-align: center;
        }

        .weather-btn:active, .weather-btn.active {
            background: #38bdf8;
            color: #0f172a;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }

        /* Gizle/G√∂ster Butonu */
        #toggle-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 23, 42, 0.8);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <button id="toggle-ui">‚öôÔ∏è</button>

    <div id="ui-container">
        <div class="weather-buttons">
            <button class="weather-btn active" onclick="setWeather('sunny')">‚òÄÔ∏è G√ºne≈ü</button>
            <button class="weather-btn" onclick="setWeather('night')">üåô Gece</button>
            <button class="weather-btn" onclick="setWeather('rain')">üåßÔ∏è Yaƒümur</button>
            <button class="weather-btn" onclick="setWeather('snow')">‚ùÑÔ∏è Kar</button>
            <button class="weather-btn" onclick="setWeather('fog')">üå´Ô∏è Sis</button>
        </div>

        <div class="control-group">
            <label>Dalga Hƒ±zƒ±</label>
            <input type="range" min="0" max="2" step="0.1" value="0.5" oninput="updateParams('speed', this.value)">
        </div>
        <div class="control-group">
            <label>Dalga Boyu</label>
            <input type="range" min="0" max="10" step="0.5" value="3" oninput="updateParams('height', this.value)">
        </div>
        <div class="control-group">
            <label>R√ºzgar/T√ºrb√ºlans</label>
            <input type="range" min="0" max="5" step="0.1" value="1" oninput="updateParams('wind', this.value)">
        </div>
    </div>

    <script>
        // --- TEMEL KURULUM ---
        const scene = new THREE.Scene();
        // Ger√ßek√ßi sis (ba≈ülangƒ±√ßta hafif mavi)
        scene.fog = new THREE.FogExp2(0xaaccff, 0.002);
        
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 30, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- I≈ûIKLANDIRMA (Ger√ßek√ßilik i√ßin) ---
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Genel aydƒ±nlƒ±k
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(-100, 100, -100);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- OKYANUS YAPISI (Shader Material) ---
        // √ñzel shader yazarak dalgalarƒ±n hem rengini hem hareketini sim√ºle ediyoruz.
        
        const waterVertexShader = `
            uniform float uTime;
            uniform float uSpeed;
            uniform float uHeight;
            uniform float uWind;
            
            varying vec2 vUv;
            varying float vElevation;

            // Basit g√ºr√ºlt√º fonksiyonu (Noise)
            vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
            float snoise(vec2 v){
                const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                        -0.577350269189626, 0.024390243902439);
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v -   i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod(i, 289.0);
                vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }

            void main() {
                vUv = uv;
                
                vec4 modelPosition = modelMatrix * vec4(position, 1.0);
                
                // Dalga matematiƒüi: Sin√ºs dalgalarƒ± + G√ºr√ºlt√º (Noise)
                float elevation = sin(modelPosition.x * 0.05 + uTime * uSpeed) * uHeight;
                elevation += sin(modelPosition.z * 0.03 + uTime * uSpeed * 0.8) * uHeight;
                
                // R√ºzgar etkisi (k√º√ß√ºk detaylar)
                elevation += snoise(modelPosition.xz * 0.1 * uWind + uTime * uSpeed) * (uHeight * 0.3);

                modelPosition.y += elevation;
                vElevation = elevation;

                vec4 viewPosition = viewMatrix * modelPosition;
                vec4 projectedPosition = projectionMatrix * viewPosition;
                gl_Position = projectedPosition;
            }
        `;

        const waterFragmentShader = `
            uniform vec3 uDepthColor;
            uniform vec3 uSurfaceColor;
            uniform float uColorOffset;
            uniform float uColorMultiplier;

            varying float vElevation;

            void main() {
                float mixStrength = (vElevation + uColorOffset) * uColorMultiplier;
                // Derinlik ve y√ºzey rengini karƒ±≈ütƒ±rarak ger√ßek√ßi tonlama
                vec3 color = mix(uDepthColor, uSurfaceColor, mixStrength);
                gl_FragColor = vec4(color, 0.9);
            }
        `;

        const waterGeometry = new THREE.PlaneGeometry(500, 500, 256, 256);
        const waterMaterial = new THREE.ShaderMaterial({
            vertexShader: waterVertexShader,
            fragmentShader: waterFragmentShader,
            uniforms: {
                uTime: { value: 0 },
                uSpeed: { value: 0.5 },
                uHeight: { value: 3.0 },
                uWind: { value: 1.0 },
                uDepthColor: { value: new THREE.Color('#186691') },
                uSurfaceColor: { value: new THREE.Color('#9bd8ff') },
                uColorOffset: { value: 2.0 },
                uColorMultiplier: { value: 0.15 }
            },
            transparent: true,
            side: THREE.DoubleSide,
            wireframe: false
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        scene.add(water);

        // --- PAR√áACIK Sƒ∞STEMƒ∞ (YAƒûMUR & KAR) ---
        let particles, particleGeo, particleMat;
        let particleSystemActive = false;
        let particleType = 'none'; // 'rain', 'snow'

        function createParticles(type) {
            if(particles) scene.remove(particles);
            
            const count = type === 'rain' ? 15000 : 10000;
            particleGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const velocities = [];

            for(let i=0; i<count*3; i+=3) {
                positions[i] = (Math.random() - 0.5) * 400; // x
                positions[i+1] = Math.random() * 200;       // y
                positions[i+2] = (Math.random() - 0.5) * 400; // z
                
                if(type === 'rain') velocities.push({y: -(Math.random() * 2 + 2), x: (Math.random()-0.5)*0.2});
                else velocities.push({y: -(Math.random() * 0.5 + 0.2), x: (Math.random()-0.5)*1});
            }

            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Texture yerine kod ile basit materyal
            particleMat = new THREE.PointsMaterial({
                color: type === 'rain' ? 0xaaaaaa : 0xffffff,
                size: type === 'rain' ? 0.8 : 1.5,
                transparent: true,
                opacity: 0.8
            });

            particles = new THREE.Points(particleGeo, particleMat);
            particles.userData = { velocities: velocities, type: type };
            scene.add(particles);
            particleSystemActive = true;
            particleType = type;
        }

        function removeParticles() {
            if(particles) {
                scene.remove(particles);
                particleSystemActive = false;
                particleType = 'none';
            }
        }

        // --- HAVA DURUMU KONTROL√ú ---
        function setWeather(type) {
            // Buton stillerini g√ºncelle
            document.querySelectorAll('.weather-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Varsayƒ±lan deƒüerler
            let fogColor = 0xaaccff;
            let fogDensity = 0.002;
            let skyColor = 0x87CEEB;
            let lightIntensity = 1.2;
            
            removeParticles();

            switch(type) {
                case 'sunny':
                    skyColor = 0x87CEEB; // A√ßƒ±k mavi
                    fogColor = 0xaaccff;
                    fogDensity = 0.002;
                    waterMaterial.uniforms.uDepthColor.value.set('#186691');
                    waterMaterial.uniforms.uSurfaceColor.value.set('#9bd8ff');
                    lightIntensity = 1.5;
                    break;
                case 'night':
                    skyColor = 0x050510; // Koyu lacivert
                    fogColor = 0x050510;
                    fogDensity = 0.015;
                    waterMaterial.uniforms.uDepthColor.value.set('#000000');
                    waterMaterial.uniforms.uSurfaceColor.value.set('#0f2030');
                    lightIntensity = 0.1;
                    break;
                case 'fog':
                    skyColor = 0xcccccc; // Gri
                    fogColor = 0xcccccc;
                    fogDensity = 0.04; // Yoƒüun sis
                    waterMaterial.uniforms.uDepthColor.value.set('#445566');
                    waterMaterial.uniforms.uSurfaceColor.value.set('#8899aa');
                    lightIntensity = 0.8;
                    break;
                case 'rain':
                    skyColor = 0x222222;
                    fogColor = 0x222222;
                    fogDensity = 0.02;
                    waterMaterial.uniforms.uDepthColor.value.set('#111111');
                    waterMaterial.uniforms.uSurfaceColor.value.set('#334455');
                    lightIntensity = 0.5;
                    createParticles('rain');
                    break;
                case 'snow':
                    skyColor = 0x8899aa;
                    fogColor = 0x99aabb;
                    fogDensity = 0.025;
                    waterMaterial.uniforms.uDepthColor.value.set('#223344');
                    waterMaterial.uniforms.uSurfaceColor.value.set('#ddeeff');
                    lightIntensity = 0.9;
                    createParticles('snow');
                    break;
            }

            // Sahne renklerini yumu≈üak ge√ßi≈üle deƒüil anlƒ±k deƒüi≈ütiriyoruz (performans i√ßin)
            renderer.setClearColor(skyColor);
            scene.fog.color.setHex(fogColor);
            scene.fog.density = fogDensity;
            dirLight.intensity = lightIntensity;
        }

        // --- PARAMETRE KONTROL√ú (UI) ---
        window.updateParams = function(param, val) {
            val = parseFloat(val);
            if(param === 'speed') waterMaterial.uniforms.uSpeed.value = val;
            if(param === 'height') waterMaterial.uniforms.uHeight.value = val;
            if(param === 'wind') waterMaterial.uniforms.uWind.value = val;
        }

        // --- UI Gƒ∞ZLE/G√ñSTER ---
        const uiContainer = document.getElementById('ui-container');
        document.getElementById('toggle-ui').addEventListener('click', () => {
            if(uiContainer.style.opacity === '0') {
                uiContainer.style.opacity = '1';
                uiContainer.style.pointerEvents = 'auto';
            } else {
                uiContainer.style.opacity = '0';
                uiContainer.style.pointerEvents = 'none';
            }
        });

        // --- ANƒ∞MASYON D√ñNG√úS√ú ---
        const clock = new THREE.Clock();

        function animate() {
            const elapsedTime = clock.getElapsedTime();

            // Suyu hareket ettir
            waterMaterial.uniforms.uTime.value = elapsedTime;

            // Par√ßacƒ±klarƒ± hareket ettir (Yaƒümur/Kar)
            if(particleSystemActive && particles) {
                const positions = particles.geometry.attributes.position.array;
                const velocities = particles.userData.velocities;

                for(let i=0; i < positions.length / 3; i++) {
                    const idx = i * 3;
                    // Y ekseninde d√º≈ü√º≈ü
                    positions[idx+1] += velocities[i].y;
                    
                    // X ekseninde r√ºzgar etkisi (hafif salƒ±nƒ±m)
                    if(particleType === 'snow') {
                         positions[idx] += Math.sin(elapsedTime + positions[idx]) * 0.1;
                    }

                    // Yere √ßarparsa (veya ekran dƒ±≈üƒ±na √ßƒ±karsa) yukarƒ± ta≈üƒ±
                    if(positions[idx+1] < -10) {
                        positions[idx+1] = 200;
                        positions[idx] = (Math.random() - 0.5) * 400; // Rastgele yeni X
                        positions[idx+2] = (Math.random() - 0.5) * 400; // Rastgele yeni Z
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            // Hafif kamera salƒ±nƒ±mƒ± (teknedeymi≈ü hissi)
            camera.position.y += Math.sin(elapsedTime * 0.5) * 0.05;

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        // --- PENCERE BOYUTLANDIRMA (RESPONSIVE) ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Ba≈ülangƒ±√ß ayarlarƒ±
        renderer.setClearColor(0x87CEEB); // G√∂ky√ºz√º rengi
        animate();

    </script>
</body>
</html>
